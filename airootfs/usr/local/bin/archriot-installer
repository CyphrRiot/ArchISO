#!/bin/bash

# ArchRiot Automated Installer
# A simple TUI installer that automates the ArchRiot installation process
# Following the exact guidelines from ArchRiot README.md

set -e

# Debug mode - set to 1 to enable debug output
DEBUG_MODE="${DEBUG_MODE:-0}"



# Tokyo Night theme colors for output
RED='\033[38;5;203m'      # Tokyo Night red
GREEN='\033[38;5;158m'    # Tokyo Night green
YELLOW='\033[38;5;221m'   # Tokyo Night yellow
BLUE='\033[38;5;116m'     # Tokyo Night cyan
PURPLE='\033[38;5;183m'   # Tokyo Night purple
ORANGE='\033[38;5;215m'   # Tokyo Night orange
GRAY='\033[38;5;59m'      # Tokyo Night comment gray
NC='\033[0m' # No Color

# Global variables
SELECTED_DISK=""
USERNAME=""
PASSWORD=""
ROOT_PASSWORD=""
LUKS_PASSWORD=""
HOSTNAME=""
WIFI_INTERFACE=""
SELECTED_TIMEZONE=""
SELECTED_KEYBOARD=""
ARCHINSTALL_CONFIG="/tmp/archriot-config.json"
ARCHINSTALL_CREDS="/tmp/archriot-creds.json"

# Logging functions with Tokyo Night styling
log() {
    echo -e "${GRAY}[$(date '+%H:%M:%S')]${NC} $1"
}

error() {
    echo -e "${RED}[‚úó ERROR]${NC} $1"
}

success() {
    echo -e "${GREEN}[‚úì SUCCESS]${NC} $1"
}

warn() {
    echo -e "${ORANGE}[‚ö† WARNING]${NC} $1"
}

# Hash password using libcrypt (same method as archinstall)
hash_password() {
    local password="$1"
    # Use Python ctypes to call libcrypt.so directly (same as archinstall)
    python3 -c "
import ctypes
import sys

# Get password from command line argument (safer than string interpolation)
password = sys.argv[1]

# Load libcrypt
libcrypt = ctypes.CDLL('libcrypt.so')
libcrypt.crypt.argtypes = [ctypes.c_char_p, ctypes.c_char_p]
libcrypt.crypt.restype = ctypes.c_char_p
libcrypt.crypt_gensalt.argtypes = [ctypes.c_char_p, ctypes.c_ulong, ctypes.c_char_p, ctypes.c_int]
libcrypt.crypt_gensalt.restype = ctypes.c_char_p

# Generate yescrypt salt (rounds=5, same as archinstall default)
salt = libcrypt.crypt_gensalt(b'\$y\$', 5, None, 0)
if not salt:
    raise ValueError('crypt_gensalt() returned NULL')

# Hash the password
password_bytes = password.encode('utf-8')
result = libcrypt.crypt(password_bytes, salt)
if not result:
    raise ValueError('crypt() returned NULL')

print(result.decode('utf-8'))
" "$password"
}

# Check if whiptail is available, fallback to basic prompts
if ! command -v whiptail &> /dev/null; then
    USE_DIALOG=false
else
    USE_DIALOG=true
fi

# Dialog wrapper functions
show_dialog() {
    if $USE_DIALOG; then
        # Handle different dialog types appropriately
        case "$1" in
            --infobox)
                # Infobox doesn't need input redirection
                # Always return 0 for infobox since it's non-interactive
                whiptail "$@" || true
                return 0
                ;;
            *)
                # Other dialogs need full terminal access
                whiptail "$@"
                local exit_code=$?
                return $exit_code
                ;;
        esac
    else
        # Fallback for basic prompts
        case "$1" in
            --msgbox)
                echo "$3"
                read -p "Press Enter to continue..."
                ;;
            --yesno)
                while true; do
                    read -p "$3 (y/n): " yn
                    case $yn in
                        [Yy]* ) return 0;;
                        [Nn]* ) return 1;;
                        * ) echo "Please answer yes or no.";;
                    esac
                done
                ;;
            --infobox)
                echo "$3"
                ;;
        esac
    fi
}

input_dialog() {
    if $USE_DIALOG; then
        whiptail --inputbox "$1" 12 60 3>&1 1>&2 2>&3
    else
        read -p "$1: " input
        echo "$input"
    fi
}

password_dialog() {
    if $USE_DIALOG; then
        whiptail --passwordbox "$1" 12 60 3>&1 1>&2 2>&3
    else
        read -s -p "$1: " password
        echo
        echo "$password"
    fi
}

menu_dialog() {
    local title="$1"
    local text="$2"
    shift 2

    if $USE_DIALOG; then
        whiptail --menu "$title" 15 60 8 "$@" 3>&1 1>&2 2>&3
    else
        echo "$text"
        echo
        local i=1
        while [ $# -gt 0 ]; do
            echo "$i) $2"
            shift 2
            i=$((i + 1))
        done
        echo
        read -p "Select option (1-$((i-1))): " choice
        if [[ "$choice" =~ ^[0-9]+$ ]] && [ "$choice" -ge 1 ] && [ "$choice" -lt "$i" ]; then
            echo "$choice"
        else
            echo ""
        fi
    fi
}

# Welcome screen
show_welcome() {
    clear
    show_dialog --msgbox "üè¥‚Äç‚ò†Ô∏è ArchRiot Installer

Welcome to the ArchRiot automated installer!

This installer will:
‚Ä¢ Set up WiFi (if needed)
‚Ä¢ Select installation disk
‚Ä¢ Configure user account
‚Ä¢ Install Arch Linux with ArchRiot-optimized settings
‚Ä¢ Install ArchRiot desktop environment

The installation follows the exact process from the ArchRiot README.md

IMPORTANT: Disk encryption (LUKS) is required and will be enabled automatically." 18 75

    if ! show_dialog --yesno "Do you want to continue with the ArchRiot installation?" 8 65; then
        exit 0
    fi
}

# Check internet connectivity
check_internet() {
    if ping -c 1 google.com &>/dev/null || ping -c 1 8.8.8.8 &>/dev/null; then
        return 0
    else
        return 1
    fi
}

# WiFi setup function
setup_wifi() {
    # Check if already connected
    if check_internet; then
        return 0
    fi

    # Check for wireless interfaces
    WIFI_INTERFACES=$(iw dev 2>/dev/null | grep Interface | awk '{print $2}' || echo "")

    if [ -z "$WIFI_INTERFACES" ]; then
        if show_dialog --yesno "No WiFi interfaces found.

Do you have an ethernet connection?
‚Ä¢ Yes: Continue with ethernet
‚Ä¢ No: Exit installer

Continue with ethernet connection?" 12 60; then
            if ! check_internet; then
                show_dialog --msgbox "No internet connection available via ethernet. Please check your connection." 8 60
                exit 1
            fi
            return 0
        else
            exit 1
        fi
    fi

    # Use first WiFi interface
    WIFI_INTERFACE=$(echo "$WIFI_INTERFACES" | head -1)

    log "Setting up WiFi on interface: $WIFI_INTERFACE"
    log "Scanning for networks..."

    # Scan for networks
    iwctl station "$WIFI_INTERFACE" scan </dev/null >/dev/null 2>&1
    if [ $? -ne 0 ]; then
        if show_dialog --yesno "WiFi scan failed on interface $WIFI_INTERFACE. Check hardware or try ethernet.

Retry scan?" 8 60; then
            setup_wifi
            return
        else
            if ! check_internet; then
                show_dialog --msgbox "No internet connection available. Cannot proceed with installation." 8 60
                exit 1
            fi
            return 0
        fi
    fi
    sleep 5

    # Get available networks - SIMPLE and RELIABLE


    # Get available networks
    RAW_OUTPUT=$(iwctl station "$WIFI_INTERFACE" get-networks </dev/null 2>&1)
    if [ "$DEBUG_MODE" = "1" ]; then
        echo "DEBUG: Raw iwctl output: $RAW_OUTPUT" >&2
    fi

    # Use simple iwctl command and parse cleanly - SIMPLE AND RELIABLE
    NETWORKS=$(echo "$RAW_OUTPUT" | grep -E "(psk|open|8021x)" | sed 's/^[[:space:]]*//' | awk '{print $1}' | head -10)

    if [ -z "$NETWORKS" ]; then
        if [ "$DEBUG_MODE" = "1" ]; then
            echo "DEBUG: No networks parsed. Raw output was: $RAW_OUTPUT" >&2
        fi
        if show_dialog --yesno "No WiFi networks found.

This could happen if:
‚Ä¢ WiFi is disabled
‚Ä¢ No networks are in range
‚Ä¢ WiFi adapter needs time to initialize

Do you want to:
‚Ä¢ Yes: Retry scanning for networks
‚Ä¢ No: Continue without WiFi (requires ethernet)

Retry WiFi scan?" 15 60; then
            setup_wifi
            return
        else
            if ! check_internet; then
                show_dialog --msgbox "No internet connection available. Cannot proceed with installation." 8 60
                exit 1
            fi
            return 0
        fi
    fi



    # Create menu items for dialog
    MENU_ITEMS=()
    i=1
    while IFS= read -r network; do
        if [ -n "$network" ] && [ "$network" != "Available" ] && [ "$network" != "networks" ]; then
            MENU_ITEMS+=("$i" "$network")
            i=$((i + 1))
        fi
    done <<< "$NETWORKS"

    # Count networks accurately after filtering for debug logging
    NETWORK_COUNT=$((${#MENU_ITEMS[@]} / 2))
    if [ "$DEBUG_MODE" = "1" ]; then
        echo "DEBUG: Found $NETWORK_COUNT networks: $(echo "$NETWORKS" | tr '\n' ', ')" >&2
    fi

    if [ ${#MENU_ITEMS[@]} -eq 0 ]; then
        if show_dialog --yesno "No valid WiFi networks found after scanning.

Do you want to:
‚Ä¢ Yes: Retry WiFi setup
‚Ä¢ No: Continue without WiFi (requires ethernet)

Retry WiFi setup?" 12 60; then
            setup_wifi
            return
        else
            if ! check_internet; then
                show_dialog --msgbox "No internet connection available. Cannot proceed with installation." 8 60
                exit 1
            fi
            return 0
        fi
    fi

    # Show network selection menu
    if [ "$DEBUG_MODE" = "1" ]; then
        echo "DEBUG: MENU_ITEMS array has ${#MENU_ITEMS[@]} items:" >&2
        for ((i=0; i<${#MENU_ITEMS[@]}; i+=2)); do
            echo "DEBUG: MENU_ITEMS[$i]='${MENU_ITEMS[i]}' MENU_ITEMS[$((i+1))]='${MENU_ITEMS[i+1]}'" >&2
        done
    fi

    SELECTION=$(menu_dialog "WiFi Networks" "Select a WiFi network:" "${MENU_ITEMS[@]}")

    if [ "$DEBUG_MODE" = "1" ]; then
        echo "DEBUG: Raw selection result: '$SELECTION'" >&2
    fi

    if [ -z "$SELECTION" ]; then
        if show_dialog --yesno "No WiFi network selected.

Do you want to:
‚Ä¢ Yes: Retry WiFi setup
‚Ä¢ No: Continue without WiFi (requires ethernet connection)

Retry WiFi setup?" 12 60; then
            setup_wifi
            return
        else
            if ! check_internet; then
                show_dialog --msgbox "No internet connection available. Cannot proceed with installation." 8 60
                exit 1
            fi
            return 0
        fi
    fi

    # Validate selection is a number
    if ! [[ "$SELECTION" =~ ^[0-9]+$ ]]; then
        show_dialog --msgbox "Invalid network selection: '$SELECTION'" 8 50
        exit 1
    fi

    # Debug: Show networks list for verification
    if [ "$DEBUG_MODE" = "1" ]; then
        echo "DEBUG: Full NETWORKS list:" >&2
        echo "$NETWORKS" | nl >&2
        echo "DEBUG: Total network lines: $(echo "$NETWORKS" | wc -l)" >&2
    fi

    # Get selected network name
    SELECTED_NETWORK=$(echo "$NETWORKS" | sed -n "${SELECTION}p" 2>/dev/null | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//')

    if [ "$DEBUG_MODE" = "1" ]; then
        echo "DEBUG: Selected network (line $SELECTION): '$SELECTED_NETWORK'" >&2
    fi

    if [ -z "$SELECTED_NETWORK" ]; then
        if [ "$DEBUG_MODE" = "1" ]; then
            echo "DEBUG: Failed to get network at line $SELECTION" >&2
            echo "DEBUG: Available lines in NETWORKS:" >&2
            echo "$NETWORKS" | cat -n >&2
        fi
        show_dialog --msgbox "Invalid network selection: selection $SELECTION out of range" 8 60
        exit 1
    fi

    # Get password
    WIFI_PASSWORD=$(password_dialog "Enter password for '$SELECTED_NETWORK'")

    # Show connection timing warning
    show_dialog --msgbox "‚è≥ Network Connection

Please wait at least 10 seconds for the network connection to establish after entering the password.

The connection process may take some time to complete." 10 60

    if [ -z "$WIFI_PASSWORD" ]; then
        # Try connecting without password (open network)
        iwctl station "$WIFI_INTERFACE" connect "$SELECTED_NETWORK" </dev/null >/dev/null 2>&1
    else
        # Connect with password
        iwctl station "$WIFI_INTERFACE" connect "$SELECTED_NETWORK" --passphrase "$WIFI_PASSWORD" </dev/null >/dev/null 2>&1
    fi

    # Wait a moment and check connection
    sleep 5

    if check_internet; then
        return 0
    else
        if show_dialog --yesno "WiFi Connection Failed

Failed to connect to '$SELECTED_NETWORK'.

This could be due to:
‚Ä¢ Incorrect password
‚Ä¢ Network issues
‚Ä¢ Signal strength problems

Do you want to:
‚Ä¢ Yes: Retry WiFi setup
‚Ä¢ No: Continue without WiFi (requires ethernet)

Retry WiFi setup?" 15 60; then
            setup_wifi
            return
        else
            warn "Continuing without WiFi - checking ethernet connection"
            if ! check_internet; then
                error "No internet connection available. Cannot proceed with installation."
                exit 1
            fi
            return 0
        fi
    fi
}

# Disk selection function
select_disk() {
    log "Scanning available disks..."

    # Get list of disks (excluding loop devices, ram, etc.)
    DISKS=$(lsblk -dno NAME,SIZE,MODEL | grep -E '^(sd|nvme|vd|hd)' | head -10)

    if [ -z "$DISKS" ]; then
        error "No suitable disks found"
        exit 1
    fi

    # Create menu items
    MENU_ITEMS=()
    while IFS= read -r disk_line; do
        if [ -n "$disk_line" ]; then
            DISK_NAME=$(echo "$disk_line" | awk '{print $1}')
            DISK_INFO="$disk_line"
            MENU_ITEMS+=("$DISK_NAME" "$DISK_INFO")
        fi
    done <<< "$DISKS"

    # Show disk selection menu
    SELECTED_DISK=$(menu_dialog "Disk Selection" "‚ö†Ô∏è  WARNING: Selected disk will be COMPLETELY ERASED!

Select installation disk:" "${MENU_ITEMS[@]}")

    if [ -z "$SELECTED_DISK" ]; then
        show_dialog --msgbox "Installation Cancelled

No disk was selected for installation.

A disk must be selected to install ArchRiot.
The installer will now exit." 10 50
        log "Installation cancelled - no disk selected"
        exit 1
    fi

    # Confirm selection
    DISK_INFO=$(echo "$DISKS" | grep "^$SELECTED_DISK")

    if ! show_dialog --yesno "‚ö†Ô∏è  FINAL WARNING ‚ö†Ô∏è

You selected: $DISK_INFO

This disk will be COMPLETELY ERASED and partitioned for ArchRiot installation.

Are you absolutely sure you want to continue?" 12 64; then
        log "Disk selection cancelled by user"
        exit 0
    fi

    SELECTED_DISK="/dev/$SELECTED_DISK"
    success "Selected disk: $SELECTED_DISK"
}

# User setup function
setup_user() {
    log "Setting up user account..."

    # Get hostname
    HOSTNAME=$(input_dialog "Enter hostname for this computer")
    while [ -z "$HOSTNAME" ] || [[ ! "$HOSTNAME" =~ ^[a-zA-Z0-9-]+$ ]]; do
        HOSTNAME=$(input_dialog "Invalid hostname. Enter hostname (letters, numbers, hyphens only)")
    done

    # Get username
    USERNAME=$(input_dialog "Enter username")
    while [ -z "$USERNAME" ] || [[ ! "$USERNAME" =~ ^[a-z_][a-z0-9_-]*$ ]]; do
        USERNAME=$(input_dialog "Invalid username. Enter username (lowercase, start with letter)")
    done

    # Show password policy info
    show_dialog --msgbox "Password Setup

For simplicity, the same password will be used for:
‚Ä¢ Your user account ($USERNAME)
‚Ä¢ Root account (admin access)

This reduces the number of passwords you need to remember." 10 60

    # Get user password (will be used for both user and root)
    PASSWORD=$(password_dialog "Enter password for $USERNAME and root")
    while [ -z "$PASSWORD" ] || [ ${#PASSWORD} -lt 6 ]; do
        PASSWORD=$(password_dialog "Password too short. Enter password (minimum 6 characters)")
    done

    # Confirm password
    PASSWORD_CONFIRM=$(password_dialog "Confirm password")
    while [ "$PASSWORD" != "$PASSWORD_CONFIRM" ]; do
        warn "Passwords do not match"
        PASSWORD=$(password_dialog "Enter password for $USERNAME and root")
        PASSWORD_CONFIRM=$(password_dialog "Confirm password")
    done

    # Use same password for root
    ROOT_PASSWORD="$PASSWORD"

    # Get LUKS encryption password
    LUKS_PASSWORD=$(password_dialog "Enter disk encryption (LUKS) password")
    while [ -z "$LUKS_PASSWORD" ] || [ ${#LUKS_PASSWORD} -lt 8 ]; do
        LUKS_PASSWORD=$(password_dialog "Encryption password too short. Enter password (minimum 8 characters)")
    done

    # Confirm LUKS password
    LUKS_PASSWORD_CONFIRM=$(password_dialog "Confirm disk encryption password")
    while [ "$LUKS_PASSWORD" != "$LUKS_PASSWORD_CONFIRM" ]; do
        warn "Encryption passwords do not match"
        LUKS_PASSWORD=$(password_dialog "Enter disk encryption (LUKS) password")
        LUKS_PASSWORD_CONFIRM=$(password_dialog "Confirm disk encryption password")
    done

    success "User configuration complete"
    log "Hostname: $HOSTNAME"
    log "Username: $USERNAME"
}

# Create archinstall configuration
create_archinstall_config() {
    log "Creating archinstall configuration..."

    cat > "$ARCHINSTALL_CONFIG" << EOF
{
    "version": "3.0.8",
    "archinstall-language": "English",
    "hostname": "$HOSTNAME",
    "kernels": ["linux"],
    "ntp": true,
    "packages": ["wget", "curl", "git", "base-devel", "networkmanager", "iwd"],
    "parallel_downloads": 5,
    "swap": true,
    "timezone": "$SELECTED_TIMEZONE",
    "bootloader": "Systemd-boot",
    "locale_config": {
        "kb_layout": "$SELECTED_KEYBOARD",
        "sys_enc": "UTF-8",
        "sys_lang": "en_US"
    },
    "disk_config": {
        "config_type": "manual_partitioning",
        "device_modifications": [
            {
                "device": "$SELECTED_DISK",
                "wipe": true,
                "partitions": [
                    {
                        "obj_id": "boot-partition",
                        "status": "create",
                        "type": "primary",
                        "start": {
                            "sector_size": {
                                "value": 512,
                                "unit": "B"
                            },
                            "unit": "MiB",
                            "value": 1
                        },
                        "size": {
                            "sector_size": {
                                "value": 512,
                                "unit": "B"
                            },
                            "unit": "GiB",
                            "value": 1
                        },
                        "fs_type": "fat32",
                        "mountpoint": "/boot",
                        "mount_options": [],
                        "flags": ["boot"],
                        "btrfs": []
                    },
                    {
                        "obj_id": "root-partition",
                        "status": "create",
                        "type": "primary",
                        "start": {
                            "sector_size": {
                                "value": 512,
                                "unit": "B"
                            },
                            "unit": "GiB",
                            "value": 1
                        },
                        "size": {
                            "sector_size": {
                                "value": 512,
                                "unit": "B"
                            },
                            "unit": "sectors",
                            "value": -1
                        },
                        "fs_type": "btrfs",
                        "mountpoint": "/",
                        "mount_options": [],
                        "flags": [],
                        "btrfs": []
                    }
                ]
            }
        ],
        "disk_encryption": {
            "encryption_type": "luks",
            "partitions": ["root-partition"],
            "lvm_volumes": []
        }
    },
    "encryption_password": "$LUKS_PASSWORD",
    "services": [],
    "custom_commands": [],
    "mirror_config": {
        "mirror_regions": {},
        "custom_servers": []
    },
    "network_config": {
        "type": "nm"
    },
    "audio_config": {
        "audio": "pipewire"
    }
}
EOF

    # Hash passwords for security (using yescrypt like Arch Linux)
    log "Hashing passwords..."
    HASHED_PASSWORD=$(hash_password "$PASSWORD")
    HASHED_ROOT_PASSWORD=$(hash_password "$ROOT_PASSWORD")

    # Create credentials file with encrypted passwords and LUKS password
    cat > "$ARCHINSTALL_CREDS" << EOF
{
    "users": [
        {
            "username": "$USERNAME",
            "enc_password": "$HASHED_PASSWORD",
            "sudo": true
        }
    ],
    "root_enc_password": "$HASHED_ROOT_PASSWORD"
}
EOF

    success "Configuration file created: $ARCHINSTALL_CONFIG"
    success "Credentials file created: $ARCHINSTALL_CREDS"
}

# Run archinstall
run_archinstall() {
    log "Starting automated Arch Linux installation..."

    show_dialog --msgbox "Starting Installation

The automated installation will now begin.
This process may take under 10 minutes depending on your internet speed.

The installer will:
‚Ä¢ Partition and encrypt $SELECTED_DISK
‚Ä¢ Install base Arch Linux system
‚Ä¢ Configure bootloader and user account
‚Ä¢ Set up networking and audio

Please be patient..." 14 70

    # Validate configuration with dry-run first
    log "Validating archinstall configuration..."
    if ! archinstall --config "$ARCHINSTALL_CONFIG" --creds "$ARCHINSTALL_CREDS" --dry-run 2>/tmp/archinstall-validation.log; then
        error "Configuration validation failed"
        show_dialog --msgbox "Configuration Invalid

The archinstall configuration is invalid and cannot be used.
This indicates a bug in the installer.

Please check /tmp/archinstall-validation.log for details.

Press OK to exit." 10 60
        exit 1
    fi
    success "Configuration validated successfully"

    # Run archinstall with our configuration and credentials
    if archinstall --config "$ARCHINSTALL_CONFIG" --creds "$ARCHINSTALL_CREDS" --silent 2>/tmp/archinstall-error.log; then
        success "Arch Linux installation completed successfully"
    else
        error "Arch Linux installation failed"
        warn "Error details may be in /tmp/archinstall-error.log"
        show_dialog --msgbox "Installation Failed

The Arch Linux installation encountered an error.
This may be due to hardware detection issues.

You can:
1. Try running the installer again
2. Check /tmp/archinstall-error.log for details
3. Use manual archinstall if the problem persists

Press OK to exit." 12 60
        exit 1
    fi
}

# Install ArchRiot welcome message for first boot
install_archriot() {
    log "Setting up ArchRiot welcome message for first boot..."

    # Transfer WiFi credentials to new system (if any exist)
    transfer_wifi_credentials

    # Create welcome script for first boot
    arch-chroot /mnt /bin/bash -c "
# Create welcome script
mkdir -p /usr/local/bin
cat > /usr/local/bin/archriot-welcome << 'WELCOME_EOF'
#!/bin/bash

# ArchRiot Welcome Message
clear
echo -e \"\033[0;35m\"
echo \"‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\"
echo \"‚ïë                    Welcome to Your New                       ‚ïë\"
echo \"‚ïë                   ArchRiot Linux System!                     ‚ïë\"
echo \"‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\"
echo -e \"\033[0m\"
echo
echo -e \"\033[1;36mNext Step: Install ArchRiot Desktop Environment\033[0m\"
echo
echo \"Run this command to install ArchRiot:\"
echo -e \"\033[1;32mcurl -fsSL https://ArchRiot.org/setup.sh | bash\033[0m\"
echo
echo \"This will install:\"
echo \"‚Ä¢ Hyprland compositor\"
echo \"‚Ä¢ ArchRiot configurations and themes\"
echo \"‚Ä¢ Essential applications\"
echo \"‚Ä¢ Development tools\"
echo
echo -e \"\033[1;33mPress Enter to continue to your shell...\033[0m\"
read
WELCOME_EOF

chmod +x /usr/local/bin/archriot-welcome

# Add welcome script to user's profile
echo '/usr/local/bin/archriot-welcome' >> /home/$USERNAME/.bashrc
"

    success "ArchRiot welcome message configured for first boot"
}

# Transfer WiFi credentials to new system
transfer_wifi_credentials() {
    log "Transferring WiFi credentials to new system..."

    # Check if NetworkManager connections exist
    if [ -d "/etc/NetworkManager/system-connections" ]; then
        # Create target directory
        mkdir -p /mnt/etc/NetworkManager/system-connections

        # Copy connection files
        if ls /etc/NetworkManager/system-connections/* >/dev/null 2>&1; then
            cp /etc/NetworkManager/system-connections/* /mnt/etc/NetworkManager/system-connections/ 2>/dev/null || true
            chmod 600 /mnt/etc/NetworkManager/system-connections/* 2>/dev/null || true
            success "WiFi credentials transferred to new system"
        else
            log "No WiFi connections to transfer"
        fi
    else
        log "No NetworkManager connections found"
    fi
}

# Select timezone
select_timezone() {
    log "Setting up timezone..."

    # Get current timezone as default
    local current_tz=$(timedatectl show --property=Timezone --value 2>/dev/null || echo "UTC")

    local timezones=(
        "UTC" "UTC (Universal)"
        "America/New_York" "US Eastern"
        "America/Chicago" "US Central"
        "America/Los_Angeles" "US Pacific"
        "America/Denver" "US Mountain"
        "America/Phoenix" "US Arizona"
        "Europe/London" "UK"
        "Europe/Paris" "Central Europe"
        "Europe/Berlin" "Germany"
        "Asia/Tokyo" "Japan"
        "Australia/Sydney" "Australia East"
    )

    SELECTED_TIMEZONE=$(menu_dialog "Timezone Selection" "Current: $current_tz\nSelect timezone:" "${timezones[@]}")

    # Use current timezone if nothing selected
    if [[ -z "$SELECTED_TIMEZONE" ]]; then
        SELECTED_TIMEZONE="$current_tz"
    fi

    # Set timezone (don't fail if we can't set it in live environment)
    if timedatectl set-timezone "$SELECTED_TIMEZONE" 2>/dev/null; then
        success "Timezone set to: $SELECTED_TIMEZONE"
    else
        warn "Cannot set timezone in live environment - will be set during installation"
        log "Selected timezone: $SELECTED_TIMEZONE"
    fi
}

# Select keyboard layout
select_keyboard() {
    log "Setting up keyboard layout..."

    # Common keyboard layouts
    local keyboards=(
        "us" "US English"
        "uk" "UK English"
        "de" "German"
        "fr" "French"
        "es" "Spanish"
        "it" "Italian"
        "pt" "Portuguese"
        "ru" "Russian"
        "jp" "Japanese"
        "kr" "Korean"
        "cn" "Chinese"
        "dvorak" "Dvorak"
        "colemak" "Colemak"
    )

    SELECTED_KEYBOARD=$(menu_dialog "Keyboard Layout" "Select your keyboard layout:" "${keyboards[@]}")

    # Use US layout as fallback if nothing selected (ESC pressed)
    if [[ -z "$SELECTED_KEYBOARD" ]]; then
        SELECTED_KEYBOARD="us"
        warn "No keyboard layout selected, using US English as default"
    fi

    # Apply keyboard layout immediately
    loadkeys "$SELECTED_KEYBOARD" 2>/dev/null || true

    success "Keyboard layout selected: $SELECTED_KEYBOARD"
}

# Main installation flow
main() {
    # Clear screen and show welcome
    clear
    show_welcome

    # Setup network if needed
    setup_wifi

    # Select timezone
    select_timezone

    # Select keyboard layout
    select_keyboard

    # Select installation disk
    select_disk

    # Get user information
    setup_user

    # Create archinstall configuration
    create_archinstall_config

    # Final confirmation
    if ! show_dialog --yesno "Ready to Install

Configuration Summary:
‚Ä¢ Disk: $SELECTED_DISK (will be encrypted with LUKS)
‚Ä¢ Hostname: $HOSTNAME
‚Ä¢ Username: $USERNAME (with sudo access)
‚Ä¢ Root account: enabled with password
‚Ä¢ Encryption: LUKS with your chosen password
‚Ä¢ Timezone: $SELECTED_TIMEZONE
‚Ä¢ Keyboard: $SELECTED_KEYBOARD
‚Ä¢ Filesystem: BTRFS with compression
‚Ä¢ Bootloader: systemd-boot
‚Ä¢ Audio: PipeWire
‚Ä¢ Desktop: ArchRiot (Hyprland)

Proceed with installation?" 18 60; then
        log "Installation cancelled by user"
        exit 0
    fi

    # Run the installation
    run_archinstall

    # Install ArchRiot
    install_archriot

    # Installation complete
    show_dialog --msgbox "üéâ Installation Complete!

ArchRiot has been successfully installed on your system.

The system will now reboot. After reboot:
‚Ä¢ Enter your disk encryption password
‚Ä¢ Log in with your user account
‚Ä¢ Enjoy your new ArchRiot system!

Note: The first boot may take a few extra moments to initialize services." 14 70

    success "ArchRiot installation completed successfully!"
    log "System will reboot in 10 seconds..."

    # Clean up
    rm -f "$ARCHINSTALL_CONFIG" /tmp/input_result /tmp/password_result /tmp/menu_result

    # Reboot
    sleep 10
    reboot
}

# Handle Ctrl+C gracefully
trap 'echo -e "\n${YELLOW}Installation interrupted by user${NC}"; exit 1' INT

# Run main function
main "$@"
