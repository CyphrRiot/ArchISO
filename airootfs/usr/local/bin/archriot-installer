#!/bin/bash

# ArchRiot Automated Installer
# A simple TUI installer that automates the ArchRiot installation process
# Following the exact guidelines from ArchRiot README.md

set -e

# Debug mode - set to 1 to enable debug output
DEBUG_MODE="${DEBUG_MODE:-0}"



# Tokyo Night theme colors for output
RED='\033[38;5;203m'      # Tokyo Night red
GREEN='\033[38;5;158m'    # Tokyo Night green
YELLOW='\033[38;5;221m'   # Tokyo Night yellow
BLUE='\033[38;5;116m'     # Tokyo Night cyan
PURPLE='\033[38;5;183m'   # Tokyo Night purple
ORANGE='\033[38;5;215m'   # Tokyo Night orange
GRAY='\033[38;5;59m'      # Tokyo Night comment gray
NC='\033[0m' # No Color

# Global variables
SELECTED_DISK=""
USERNAME=""
PASSWORD=""
ROOT_PASSWORD=""
LUKS_PASSWORD=""
HOSTNAME=""
WIFI_INTERFACE=""
SELECTED_TIMEZONE=""
SELECTED_KEYBOARD=""
ARCHINSTALL_CONFIG="/tmp/archriot-config.json"
ARCHINSTALL_CREDS="/tmp/archriot-creds.json"

# Logging functions with Tokyo Night styling
log() {
    echo -e "${GRAY}[$(date '+%H:%M:%S')]${NC} $1"
}

error() {
    echo -e "${RED}[✗ ERROR]${NC} $1"
}

success() {
    echo -e "${GREEN}[✓ SUCCESS]${NC} $1"
}

warn() {
    echo -e "${ORANGE}[⚠ WARNING]${NC} $1"
}

# Hash password using libcrypt (same method as archinstall)
hash_password() {
    local password="$1"
    # Use Python ctypes to call libcrypt.so directly (same as archinstall)
    python3 -c "
import ctypes
import sys

# Get password from command line argument (safer than string interpolation)
password = sys.argv[1]

# Load libcrypt
libcrypt = ctypes.CDLL('libcrypt.so')
libcrypt.crypt.argtypes = [ctypes.c_char_p, ctypes.c_char_p]
libcrypt.crypt.restype = ctypes.c_char_p
libcrypt.crypt_gensalt.argtypes = [ctypes.c_char_p, ctypes.c_ulong, ctypes.c_char_p, ctypes.c_int]
libcrypt.crypt_gensalt.restype = ctypes.c_char_p

# Generate yescrypt salt (rounds=5, same as archinstall default)
salt = libcrypt.crypt_gensalt(b'\$y\$', 5, None, 0)
if not salt:
    raise ValueError('crypt_gensalt() returned NULL')

# Hash the password
password_bytes = password.encode('utf-8')
result = libcrypt.crypt(password_bytes, salt)
if not result:
    raise ValueError('crypt() returned NULL')

print(result.decode('utf-8'))
" "$password"
}

# Check if whiptail is available, fallback to basic prompts
if ! command -v whiptail &> /dev/null; then
    USE_DIALOG=false
else
    USE_DIALOG=true
fi

# Dialog wrapper functions
show_dialog() {
    if $USE_DIALOG; then
        # Handle different dialog types appropriately
        case "$1" in
            --infobox)
                # Infobox doesn't need input redirection
                # Always return 0 for infobox since it's non-interactive
                whiptail "$@" || true
                return 0
                ;;
            *)
                # Other dialogs need full terminal access
                whiptail "$@"
                local exit_code=$?
                return $exit_code
                ;;
        esac
    else
        # Fallback for basic prompts
        case "$1" in
            --msgbox)
                echo "$3"
                read -p "Press Enter to continue..."
                ;;
            --yesno)
                while true; do
                    read -p "$3 (y/n): " yn
                    case $yn in
                        [Yy]* ) return 0;;
                        [Nn]* ) return 1;;
                        * ) echo "Please answer yes or no.";;
                    esac
                done
                ;;
            --infobox)
                echo "$3"
                ;;
        esac
    fi
}

input_dialog() {
    if $USE_DIALOG; then
        whiptail --inputbox "$1" 12 60 3>&1 1>&2 2>&3
    else
        read -p "$1: " input
        echo "$input"
    fi
}

password_dialog() {
    if $USE_DIALOG; then
        whiptail --passwordbox "$1" 12 60 3>&1 1>&2 2>&3
    else
        read -s -p "$1: " password
        echo
        echo "$password"
    fi
}

menu_dialog() {
    local title="$1"
    local text="$2"
    shift 2

    if $USE_DIALOG; then
        whiptail --menu "$title" 15 60 8 "$@" 3>&1 1>&2 2>&3
    else
        echo "$text"
        echo
        local i=1
        while [ $# -gt 0 ]; do
            echo "$i) $2"
            shift 2
            i=$((i + 1))
        done
        echo
        read -p "Select option (1-$((i-1))): " choice
        if [[ "$choice" =~ ^[0-9]+$ ]] && [ "$choice" -ge 1 ] && [ "$choice" -lt "$i" ]; then
            echo "$choice"
        else
            echo ""
        fi
    fi
}

# Welcome screen
show_welcome() {
    clear
    show_dialog --msgbox "🏴‍☠️ ArchRiot Installer

Welcome to the ArchRiot automated installer!

This installer will:
• Set up WiFi (if needed)
• Select installation disk
• Configure user account
• Install Arch Linux with ArchRiot-optimized settings
• Install ArchRiot desktop environment

The installation follows the exact process from the ArchRiot README.md

IMPORTANT: Disk encryption (LUKS) is required and will be enabled automatically." 18 75

    if ! show_dialog --yesno "Do you want to continue with the ArchRiot installation?" 8 65; then
        exit 0
    fi
}

# Check internet connectivity
check_internet() {
    if ping -c 1 google.com &>/dev/null || ping -c 1 8.8.8.8 &>/dev/null; then
        return 0
    else
        return 1
    fi
}

# WiFi setup function
setup_wifi() {
    local retry_count=${1:-0}
    local max_retries=3

    # Prevent infinite loops
    if [ $retry_count -ge $max_retries ]; then
        error "WiFi setup failed after $max_retries attempts"
        show_dialog --msgbox "WiFi Setup Failed

Unable to connect to WiFi after multiple attempts.
Please check your network or use ethernet connection.

The installer will exit." 10 60
        exit 1
    fi

    # Check if already connected
    if check_internet; then
        return 0
    fi

    # Check for wireless interfaces
    WIFI_INTERFACES=$(iw dev 2>/dev/null | grep Interface | awk '{print $2}' || echo "")

    if [ -z "$WIFI_INTERFACES" ]; then
        if show_dialog --yesno "No WiFi interfaces found.

Do you have an ethernet connection?
• Yes: Continue with ethernet
• No: Exit installer

Continue with ethernet connection?" 12 60; then
            if ! check_internet; then
                show_dialog --msgbox "No internet connection available via ethernet. Please check your connection." 8 60
                exit 1
            fi
            return 0
        else
            exit 1
        fi
    fi

    # Use first WiFi interface
    WIFI_INTERFACE=$(echo "$WIFI_INTERFACES" | head -1)

    # Show user feedback during network scanning
    show_dialog --infobox "Scanning for WiFi networks...

This may take 5-10 seconds.
Please wait..." 8 50

    # Scan for networks
    iwctl station "$WIFI_INTERFACE" scan </dev/null >/dev/null 2>&1
    if [ $? -ne 0 ]; then
        if show_dialog --yesno "WiFi scan failed on interface $WIFI_INTERFACE. Check hardware or try ethernet.

Retry scan?" 8 60; then
            setup_wifi $((retry_count + 1))
            return
        else
            if ! check_internet; then
                show_dialog --msgbox "No internet connection available. Cannot proceed with installation." 8 60
                exit 1
            fi
            return 0
        fi
    fi
    sleep 5

    # Get available networks - SIMPLE and RELIABLE


    # Get currently connected network to filter it out
    CURRENT_NETWORK=$(iwctl station "$WIFI_INTERFACE" show </dev/null 2>/dev/null | grep "Connected network" | awk '{print $3}' | tr -d '*')

    # Get available networks
    RAW_OUTPUT=$(iwctl station "$WIFI_INTERFACE" get-networks </dev/null 2>&1)
    if [ "$DEBUG_MODE" = "1" ]; then
        echo "DEBUG: Raw iwctl output: $RAW_OUTPUT" >&2
        echo "DEBUG: Currently connected to: '$CURRENT_NETWORK'" >&2
    fi

    # Parse networks and filter out current connection and empty lines
    NETWORKS=$(echo "$RAW_OUTPUT" | grep -E "(psk|open|8021x)" | sed 's/\x1b\[[0-9;]*m//g' | sed 's/^[[:space:]]*>[[:space:]]*//' | sed 's/^[[:space:]]*//' | awk '{print $1}' | grep -v '^$' | grep -v "^$CURRENT_NETWORK$" | sed '/^$/d' | head -10)

    if [ -z "$NETWORKS" ]; then
        if [ "$DEBUG_MODE" = "1" ]; then
            echo "DEBUG: No networks parsed. Raw output was: $RAW_OUTPUT" >&2
        fi
        if show_dialog --yesno "No WiFi networks found.

This could happen if:
• WiFi is disabled
• No networks are in range
• WiFi adapter needs time to initialize

Do you want to:
• Yes: Retry scanning for networks
• No: Continue without WiFi (requires ethernet)

Retry WiFi scan?" 15 60; then
            setup_wifi $((retry_count + 1))
            return
        else
            if ! check_internet; then
                show_dialog --msgbox "No internet connection available. Cannot proceed with installation." 8 60
                exit 1
            fi
            return 0
        fi
    fi



    # Create menu items for dialog
    MENU_ITEMS=()
    i=1
    while IFS= read -r network; do
        echo "DEBUG: Processing network line: '$network' (length: $(echo -n "$network" | wc -c))" >&2
        if [ -n "$network" ] && [ "$network" != "Available" ] && [ "$network" != "networks" ]; then
            echo "DEBUG: Adding to menu: '$i' '$network'" >&2
            MENU_ITEMS+=("$i" "$network")
            i=$((i + 1))
        else
            echo "DEBUG: Skipping network: '$network'" >&2
        fi
    done <<< "$NETWORKS"

    # Count networks accurately after filtering for debug logging
    NETWORK_COUNT=$((${#MENU_ITEMS[@]} / 2))
    if [ "$DEBUG_MODE" = "1" ]; then
        echo "DEBUG: Found $NETWORK_COUNT networks: $(echo "$NETWORKS" | tr '\n' ', ')" >&2
    fi

    if [ ${#MENU_ITEMS[@]} -eq 0 ]; then
        if show_dialog --yesno "No valid WiFi networks found after scanning.

Do you want to:
• Yes: Retry WiFi setup
• No: Continue without WiFi (requires ethernet)

Retry WiFi setup?" 12 60; then
            setup_wifi $((retry_count + 1))
            return
        else
            if ! check_internet; then
                show_dialog --msgbox "No internet connection available. Cannot proceed with installation." 8 60
                exit 1
            fi
            return 0
        fi
    fi

    # Show network selection menu
    if [ "$DEBUG_MODE" = "1" ]; then
        echo "DEBUG: MENU_ITEMS array has ${#MENU_ITEMS[@]} items:" >&2
        for ((i=0; i<${#MENU_ITEMS[@]}; i+=2)); do
            echo "DEBUG: MENU_ITEMS[$i]='${MENU_ITEMS[i]}' MENU_ITEMS[$((i+1))]='${MENU_ITEMS[i+1]}'" >&2
        done
    fi

    SELECTION=$(menu_dialog "WiFi Networks" "Select a WiFi network:" "${MENU_ITEMS[@]}")

    if [ "$DEBUG_MODE" = "1" ]; then
        echo "DEBUG: Raw selection result: '$SELECTION'" >&2
    fi

    if [ -z "$SELECTION" ]; then
        if show_dialog --yesno "No WiFi network selected.

Do you want to:
• Yes: Retry WiFi setup
• No: Continue without WiFi (requires ethernet connection)

Retry WiFi setup?" 12 60; then
            setup_wifi $((retry_count + 1))
            return
        else
            if ! check_internet; then
                show_dialog --msgbox "No internet connection available. Cannot proceed with installation." 8 60
                exit 1
            fi
            return 0
        fi
    fi

    # Validate selection is a number
    if ! [[ "$SELECTION" =~ ^[0-9]+$ ]]; then
        show_dialog --msgbox "Invalid network selection: '$SELECTION'" 8 50
        exit 1
    fi

    # Debug: Show networks list for verification
    if [ "$DEBUG_MODE" = "1" ]; then
        echo "DEBUG: Full NETWORKS list:" >&2
        echo "$NETWORKS" | nl >&2
        echo "DEBUG: Total network lines: $(echo "$NETWORKS" | wc -l)" >&2
    fi

    # Get selected network name
    SELECTED_NETWORK=$(echo "$NETWORKS" | sed -n "${SELECTION}p" 2>/dev/null | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//')

    if [ "$DEBUG_MODE" = "1" ]; then
        echo "DEBUG: Selected network (line $SELECTION): '$SELECTED_NETWORK'" >&2
    fi

    if [ -z "$SELECTED_NETWORK" ]; then
        if [ "$DEBUG_MODE" = "1" ]; then
            echo "DEBUG: Failed to get network at line $SELECTION" >&2
            echo "DEBUG: Available lines in NETWORKS:" >&2
            echo "$NETWORKS" | cat -n >&2
        fi
        show_dialog --msgbox "Invalid network selection: selection $SELECTION out of range" 8 60
        exit 1
    fi

    # Get password
    WIFI_PASSWORD=$(password_dialog "Enter password for '$SELECTED_NETWORK'")

    # Show connection timing warning
    show_dialog --msgbox " -=- Network Connection -=-

Please wait at least 10 seconds for the network connection after pressing ENTER (for OK).

The connection process may take some time to complete." 10 60

    if [ -z "$WIFI_PASSWORD" ]; then
        # Try connecting without password (open network)
        iwctl station "$WIFI_INTERFACE" connect "$SELECTED_NETWORK" </dev/null >/dev/null 2>&1
    else
        # Connect with password
        iwctl station "$WIFI_INTERFACE" connect "$SELECTED_NETWORK" --passphrase "$WIFI_PASSWORD" </dev/null >/dev/null 2>&1
    fi

    # Wait a moment and check connection
    sleep 5

    if check_internet; then
        return 0
    else
        if show_dialog --yesno "WiFi Connection Failed

Failed to connect to '$SELECTED_NETWORK'.

This could be due to:
• Incorrect password
• Network issues
• Signal strength problems

Do you want to:
• Yes: Retry WiFi setup
• No: Continue without WiFi (requires ethernet)

Retry WiFi setup?" 15 60; then
            setup_wifi $((retry_count + 1))
            return
        else
            warn "Continuing without WiFi - checking ethernet connection"
            if ! check_internet; then
                error "No internet connection available. Cannot proceed with installation."
                exit 1
            fi
            return 0
        fi
    fi
}

# Disk selection function
select_disk() {
    # Scanning disks silently to avoid disrupting TUI

    # Detect boot device to exclude it from installation options
    BOOT_DEVICE=""
    # Check for mounted boot devices (USB drives, etc.)
    for mount_point in $(mount | grep -E '^/dev/(sd|nvme|vd)' | awk '{print $1}' | sed 's/[0-9]*$//' | sort -u); do
        # Check if this device contains the running system
        if mount | grep -q "$mount_point.*\(rw\|ro\).*archiso"; then
            BOOT_DEVICE=$(basename "$mount_point")
            break
        fi
    done

    # If no archiso mount found, check for removable media
    if [ -z "$BOOT_DEVICE" ]; then
        BOOT_DEVICE=$(lsblk -dno NAME,RM,TRAN | awk '$2==1 && $3=="usb" {print $1}' | head -1)
    fi

    # Boot device detection handled silently

    # Get list of disks (excluding loop devices, ram, boot device, etc.)
    if [ -n "$BOOT_DEVICE" ]; then
        DISKS=$(lsblk -dno NAME,SIZE,MODEL | grep -E '^(sd|nvme|vd|hd)' | grep -v "^$BOOT_DEVICE " | head -10)
    else
        DISKS=$(lsblk -dno NAME,SIZE,MODEL | grep -E '^(sd|nvme|vd|hd)' | head -10)
    fi

    if [ -z "$DISKS" ]; then
        error "No suitable disks found for installation"
        if [ -n "$BOOT_DEVICE" ]; then
            error "Only boot device /dev/$BOOT_DEVICE detected - cannot install to boot device"
        fi
        exit 1
    fi

    # Create menu items
    MENU_ITEMS=()
    while IFS= read -r disk_line; do
        if [ -n "$disk_line" ]; then
            DISK_NAME=$(echo "$disk_line" | awk '{print $1}')
            DISK_INFO="$disk_line"
            MENU_ITEMS+=("$DISK_NAME" "$DISK_INFO")
        fi
    done <<< "$DISKS"

    # Show disk selection menu
    SELECTED_DISK=$(menu_dialog "Disk Selection" "⚠️  WARNING: Selected disk will be COMPLETELY ERASED!

Select installation disk:" "${MENU_ITEMS[@]}")

    if [ -z "$SELECTED_DISK" ]; then
        show_dialog --msgbox "Installation Cancelled

No disk was selected for installation.

A disk must be selected to install ArchRiot.
The installer will now exit." 10 50
        log "Installation cancelled - no disk selected"
        exit 1
    fi

    # Confirm selection
    DISK_INFO=$(echo "$DISKS" | grep "^$SELECTED_DISK")

    if ! show_dialog --yesno "!!! FINAL WARNING !!!

You selected: $DISK_INFO

This disk will be COMPLETELY ERASED and partitioned for ArchRiot installation.

Are you absolutely sure you want to continue?" 12 64; then
        log "Disk selection cancelled by user"
        exit 0
    fi

    SELECTED_DISK="/dev/$SELECTED_DISK"
    success "Selected disk: $SELECTED_DISK"
}

# User setup function
setup_user() {
    log "Setting up user account..."

    # Get hostname
    HOSTNAME=$(input_dialog "Enter hostname for this computer")
    while [ -z "$HOSTNAME" ] || [[ ! "$HOSTNAME" =~ ^[a-zA-Z0-9-]+$ ]]; do
        HOSTNAME=$(input_dialog "Invalid hostname. Enter hostname (letters, numbers, hyphens only)")
    done

    # Get username
    USERNAME=$(input_dialog "Enter username")
    while [ -z "$USERNAME" ] || [[ ! "$USERNAME" =~ ^[a-z_][a-z0-9_-]*$ ]]; do
        USERNAME=$(input_dialog "Invalid username. Enter username (lowercase, start with letter)")
    done

    # Show password policy info
    show_dialog --msgbox "Password Setup

For simplicity, the same password will be used for:
• Your user account ($USERNAME)
• Root account (admin access)

This reduces the number of passwords you need to remember." 10 60

    # Get user password (will be used for both user and root)
    PASSWORD=$(password_dialog "Enter password for $USERNAME and root")
    while [ -z "$PASSWORD" ] || [ ${#PASSWORD} -lt 6 ]; do
        PASSWORD=$(password_dialog "Password too short. Enter password (minimum 6 characters)")
    done

    # Confirm password
    PASSWORD_CONFIRM=$(password_dialog "Confirm password")
    while [ "$PASSWORD" != "$PASSWORD_CONFIRM" ]; do
        warn "Passwords do not match"
        PASSWORD=$(password_dialog "Enter password for $USERNAME and root")
        PASSWORD_CONFIRM=$(password_dialog "Confirm password")
    done

    # Use same password for root
    ROOT_PASSWORD="$PASSWORD"

    # Get LUKS encryption password
    LUKS_PASSWORD=$(password_dialog "Enter disk encryption (LUKS) password")
    while [ -z "$LUKS_PASSWORD" ] || [ ${#LUKS_PASSWORD} -lt 8 ]; do
        LUKS_PASSWORD=$(password_dialog "Encryption password too short. Enter password (minimum 8 characters)")
    done

    # Confirm LUKS password
    LUKS_PASSWORD_CONFIRM=$(password_dialog "Confirm disk encryption password")
    while [ "$LUKS_PASSWORD" != "$LUKS_PASSWORD_CONFIRM" ]; do
        warn "Encryption passwords do not match"
        LUKS_PASSWORD=$(password_dialog "Enter disk encryption (LUKS) password")
        LUKS_PASSWORD_CONFIRM=$(password_dialog "Confirm disk encryption password")
    done

    success "User configuration complete"
    log "Hostname: $HOSTNAME"
    log "Username: $USERNAME"
}

# Create archinstall configuration
create_archinstall_config() {
    log "Creating archinstall configuration..."

    # Hash passwords for security (using yescrypt like Arch Linux)
    log "Hashing passwords..."
    HASHED_PASSWORD=$(hash_password "$PASSWORD")
    HASHED_ROOT_PASSWORD=$(hash_password "$ROOT_PASSWORD")

    # Calculate dynamic partition sizes based on selected disk
    DISK_SIZE_BYTES=$(lsblk -dno SIZE "$SELECTED_DISK" --bytes)

    # Calculate aligned partition boundaries (1 MiB = 1048576 bytes)
    # Boot partition: 1 MiB start, 1 GiB size
    BOOT_START_BYTES=1048576  # 1 MiB aligned start
    BOOT_SIZE_BYTES=1073741824  # 1 GiB exact

    # Root partition: starts after boot partition, aligned to 1 MiB boundary
    ROOT_START_BYTES=$((BOOT_START_BYTES + BOOT_SIZE_BYTES))  # 1025 MiB start

    # Root size: remaining space minus GPT backup (1 MiB for GPT backup header)
    ROOT_SIZE_BYTES=$((DISK_SIZE_BYTES - ROOT_START_BYTES - 1048576))

    # Generate unique partition IDs
    BOOT_ID=$(uuidgen)
    ROOT_ID=$(uuidgen)

    # Create main configuration file
    cat > "$ARCHINSTALL_CONFIG" << EOF
{
    "archinstall-language": "English",
    "audio_config": {
        "audio": "pipewire"
    },
    "bootloader": "Systemd-boot",
    "custom_commands": [],
    "disk_config": {
        "btrfs_options": {
            "snapshot_config": null
        },
        "config_type": "default_layout",
        "device_modifications": [
            {
                "device": "$SELECTED_DISK",
                "partitions": [
                    {
                        "btrfs": [],
                        "dev_path": null,
                        "flags": ["boot", "esp"],
                        "fs_type": "fat32",
                        "mount_options": [],
                        "mountpoint": "/boot",
                        "obj_id": "$BOOT_ID",
                        "size": {
                            "sector_size": {
                                "unit": "B",
                                "value": 512
                            },
                            "unit": "B",
                            "value": $BOOT_SIZE_BYTES
                        },
                        "start": {
                            "sector_size": {
                                "unit": "B",
                                "value": 512
                            },
                            "unit": "B",
                            "value": $BOOT_START_BYTES
                        },
                        "status": "create",
                        "type": "primary"
                    },
                    {
                        "btrfs": [
                            {
                                "mountpoint": "/",
                                "name": "@"
                            },
                            {
                                "mountpoint": "/home",
                                "name": "@home"
                            },
                            {
                                "mountpoint": "/var/log",
                                "name": "@log"
                            },
                            {
                                "mountpoint": "/var/cache/pacman/pkg",
                                "name": "@pkg"
                            }
                        ],
                        "dev_path": null,
                        "flags": [],
                        "fs_type": "btrfs",
                        "mount_options": ["compress=zstd"],
                        "mountpoint": null,
                        "obj_id": "$ROOT_ID",
                        "size": {
                            "sector_size": {
                                "unit": "B",
                                "value": 512
                            },
                            "unit": "B",
                            "value": $ROOT_SIZE_BYTES
                        },
                        "start": {
                            "sector_size": {
                                "unit": "B",
                                "value": 512
                            },
                            "unit": "B",
                            "value": $ROOT_START_BYTES
                        },
                        "status": "create",
                        "type": "primary"
                    }
                ],
                "wipe": true
            }
        ],
        "disk_encryption": {
            "encryption_type": "luks",
            "partitions": ["$ROOT_ID"],
            "lvm_volumes": []
        }
    },
    "hostname": "$HOSTNAME",
    "kernels": [
        "linux"
    ],
    "locale_config": {
        "kb_layout": "$SELECTED_KEYBOARD",
        "sys_enc": "UTF-8",
        "sys_lang": "en_US.UTF-8"
    },

    "network_config": {
        "type": "iso"
    },
    "ntp": true,
    "packages": [
        "wget", "curl", "git", "base-devel", "networkmanager", "iwd"
    ],
    "parallel_downloads": 0,
    "services": [],
    "swap": false,
    "timezone": "$SELECTED_TIMEZONE",
    "version": null
}
EOF

    # Create separate credentials file with secure permissions
    umask 077
    cat > "$ARCHINSTALL_CREDS" << EOF
{
    "users": [
        {
            "username": "$USERNAME",
            "enc_password": "$HASHED_PASSWORD",
            "sudo": true
        }
    ],
    "root_enc_password": "$HASHED_ROOT_PASSWORD",
    "encryption_password": "$LUKS_PASSWORD"
}
EOF
    umask 022

    success "Configuration file created: $ARCHINSTALL_CONFIG"
    success "Credentials file created: $ARCHINSTALL_CREDS"
}

# Run archinstall
run_archinstall() {
    log "Starting automated Arch Linux installation..."

    show_dialog --msgbox "Starting Installation

The automated installation will now begin.
This process may take under 10 minutes depending on your internet speed.

The installer will:
• Partition and encrypt $SELECTED_DISK
• Install base Arch Linux system
• Configure bootloader and user account
• Set up networking and audio

Please be patient..." 14 70

    # Validate configuration with dry-run first
    log "Validating archinstall configuration..."

    # First check if config files exist and are readable
    if [ ! -f "$ARCHINSTALL_CONFIG" ]; then
        error "Config file not found: $ARCHINSTALL_CONFIG"
        exit 1
    fi

    if [ ! -f "$ARCHINSTALL_CREDS" ]; then
        error "Credentials file not found: $ARCHINSTALL_CREDS"
        exit 1
    fi

    # Show what we're validating
    log "Config file size: $(wc -c < "$ARCHINSTALL_CONFIG") bytes"
    log "Creds file size: $(wc -c < "$ARCHINSTALL_CREDS") bytes"

    # Capture both stdout and stderr for debugging
    if ! archinstall --config "$ARCHINSTALL_CONFIG" --creds "$ARCHINSTALL_CREDS" --dry-run --silent > /tmp/archinstall-validation.log 2>&1; then
        error "Configuration validation failed"

        # Show detailed error information
        echo "=== ARCHINSTALL VALIDATION ERROR ===" >&2
        echo "Config file contents:" >&2
        cat "$ARCHINSTALL_CONFIG" >&2
        echo "" >&2
        echo "Credentials file contents:" >&2
        cat "$ARCHINSTALL_CREDS" >&2
        echo "" >&2
        echo "Validation output:" >&2
        cat /tmp/archinstall-validation.log >&2
        echo "===================================" >&2

        show_dialog --msgbox "Configuration Invalid

The archinstall configuration failed validation.

ERROR DETAILS:
$(cat /tmp/archinstall-validation.log | head -10)

Check the terminal output for full details.

Press OK to exit." 16 70
        exit 1
    fi
    success "Configuration validated successfully"

    # Disable reflector to prevent hanging
    log "Disabling reflector service to prevent hanging..."
    systemctl mask reflector.service 2>/dev/null || true
    systemctl stop reflector.service 2>/dev/null || true

    # Run archinstall with our configuration and credentials
    if archinstall --config "$ARCHINSTALL_CONFIG" --creds "$ARCHINSTALL_CREDS" --silent > /tmp/archinstall-error.log 2>&1; then
        success "Arch Linux installation completed successfully"
    else
        error "Arch Linux installation failed"
        warn "Error details may be in /tmp/archinstall-error.log"
        show_dialog --msgbox "Installation Failed

The Arch Linux installation encountered an error.
This may be due to hardware detection issues.

You can:
1. Try running the installer again
2. Check /tmp/archinstall-error.log for details
3. Use manual archinstall if the problem persists

Press OK to exit." 12 60
        exit 1
    fi
}

# Install ArchRiot welcome message for first boot
install_archriot() {
    log "Setting up ArchRiot welcome message for first boot..."

    # Transfer WiFi credentials to new system (if any exist)
    transfer_wifi_credentials

    # Create welcome script for first boot
    arch-chroot /mnt /bin/bash -c "
# Create welcome script
mkdir -p /usr/local/bin
cat > /usr/local/bin/archriot-welcome << 'WELCOME_EOF'
#!/bin/bash

# ArchRiot Welcome Message
clear
echo -e \"\033[0;35m\"
echo \"╔══════════════════════════════════════════════════════════════╗\"
echo \"║                    Welcome to Your New                       ║\"
echo \"║                   ArchRiot Linux System!                     ║\"
echo \"╚══════════════════════════════════════════════════════════════╝\"
echo -e \"\033[0m\"
echo
echo -e \"\033[1;36mNext Step: Install ArchRiot Desktop Environment\033[0m\"
echo
echo \"Run this command to install ArchRiot:\"
echo -e \"\033[1;32mcurl -fsSL https://ArchRiot.org/setup.sh | bash\033[0m\"
echo
echo \"This will install:\"
echo \"• Hyprland compositor\"
echo \"• ArchRiot configurations and themes\"
echo \"• Essential applications\"
echo \"• Development tools\"
echo
echo -e \"\033[1;33mPress Enter to continue to your shell...\033[0m\"
read
WELCOME_EOF

chmod +x /usr/local/bin/archriot-welcome

# Add welcome script to user's profile
echo '/usr/local/bin/archriot-welcome' >> /home/$USERNAME/.bashrc
"

    success "ArchRiot welcome message configured for first boot"
}

# Transfer WiFi credentials to new system
transfer_wifi_credentials() {
    log "Transferring WiFi credentials to new system..."

    # Check if NetworkManager connections exist
    if [ -d "/etc/NetworkManager/system-connections" ]; then
        # Create target directory
        mkdir -p /mnt/etc/NetworkManager/system-connections

        # Copy connection files
        if ls /etc/NetworkManager/system-connections/* >/dev/null 2>&1; then
            cp /etc/NetworkManager/system-connections/* /mnt/etc/NetworkManager/system-connections/ 2>/dev/null || true
            chmod 600 /mnt/etc/NetworkManager/system-connections/* 2>/dev/null || true
            success "WiFi credentials transferred to new system"
        else
            log "No WiFi connections to transfer"
        fi
    else
        log "No NetworkManager connections found"
    fi
}

# Select timezone
select_timezone() {
    log "Setting up timezone..."

    # Get current timezone as default
    local current_tz=$(timedatectl show --property=Timezone --value 2>/dev/null || echo "UTC")

    local timezones=(
        "UTC" "UTC (Universal)"
        "America/New_York" "US Eastern"
        "America/Chicago" "US Central"
        "America/Los_Angeles" "US Pacific"
        "America/Denver" "US Mountain"
        "America/Phoenix" "US Arizona"
        "Europe/London" "UK"
        "Europe/Paris" "Central Europe"
        "Europe/Berlin" "Germany"
        "Asia/Tokyo" "Japan"
        "Australia/Sydney" "Australia East"
    )

    SELECTED_TIMEZONE=$(menu_dialog "Timezone Selection" "Current: $current_tz\nSelect timezone:" "${timezones[@]}")

    # Use current timezone if nothing selected
    if [[ -z "$SELECTED_TIMEZONE" ]]; then
        SELECTED_TIMEZONE="$current_tz"
    fi

    # Set timezone (don't fail if we can't set it in live environment)
    if timedatectl set-timezone "$SELECTED_TIMEZONE" 2>/dev/null; then
        success "Timezone set to: $SELECTED_TIMEZONE"
    else
        warn "Cannot set timezone in live environment - will be set during installation"
        log "Selected timezone: $SELECTED_TIMEZONE"
    fi
}

# Select keyboard layout
select_keyboard() {
    log "Setting up keyboard layout..."

    # Common keyboard layouts
    local keyboards=(
        "us" "US English"
        "uk" "UK English"
        "de" "German"
        "fr" "French"
        "es" "Spanish"
        "it" "Italian"
        "pt" "Portuguese"
        "ru" "Russian"
        "jp" "Japanese"
        "kr" "Korean"
        "cn" "Chinese"
        "dvorak" "Dvorak"
        "colemak" "Colemak"
    )

    SELECTED_KEYBOARD=$(menu_dialog "Keyboard Layout" "Select your keyboard layout:" "${keyboards[@]}")

    # Use US layout as fallback if nothing selected (ESC pressed)
    if [[ -z "$SELECTED_KEYBOARD" ]]; then
        SELECTED_KEYBOARD="us"
        warn "No keyboard layout selected, using US English as default"
    fi

    # Apply keyboard layout immediately
    loadkeys "$SELECTED_KEYBOARD" 2>/dev/null || true

    success "Keyboard layout selected: $SELECTED_KEYBOARD"
}

# Main installation flow
main() {
    # Clear screen and show welcome
    clear
    show_welcome

    # Setup network if needed
    setup_wifi

    # Select timezone
    select_timezone

    # Select keyboard layout
    select_keyboard

    # Select installation disk
    select_disk

    # Get user information
    setup_user

    # Create archinstall configuration
    create_archinstall_config

    # Final confirmation
    if ! show_dialog --yesno "Ready to Install

Configuration Summary:
• Disk: $SELECTED_DISK (will be encrypted with LUKS)
• Hostname: $HOSTNAME
• Username: $USERNAME (with sudo access)
• Root account: enabled with password
• Encryption: LUKS with your chosen password
• Timezone: $SELECTED_TIMEZONE
• Keyboard: $SELECTED_KEYBOARD
• Filesystem: BTRFS with compression
• Bootloader: systemd-boot
• Audio: PipeWire
• Desktop: ArchRiot (Hyprland)

Proceed with installation?" 18 60; then
        log "Installation cancelled by user"
        exit 0
    fi

    # Run the installation
    run_archinstall

    # Install ArchRiot
    install_archriot

    # Installation complete
    show_dialog --msgbox "🎉 Installation Complete!

ArchRiot has been successfully installed on your system.

The system will now reboot. After reboot:
• Enter your disk encryption password
• Log in with your user account
• Enjoy your new ArchRiot system!

Note: The first boot may take a few extra moments to initialize services." 14 70

    success "ArchRiot installation completed successfully!"

    # Show post-install ArchRiot setup instructions
    show_dialog --msgbox "🎉 Installation Complete! 🎉

Base Arch Linux system has been installed successfully!

IMPORTANT - Complete Your ArchRiot Setup:

After the system reboots and you log in, run this command to finish setting up ArchRiot:

curl -fsSL https://ArchRiot.org/setup.sh | bash

This will install:
• Hyprland desktop environment
• All ArchRiot configurations
• Essential applications and themes

Press OK to reboot and complete your ArchRiot installation!" 18 75

    log "System will reboot in 10 seconds..."

    # Clean up sensitive files securely
    shred -vfz -n 3 "$ARCHINSTALL_CONFIG" 2>/dev/null || rm -f "$ARCHINSTALL_CONFIG"
    shred -vfz -n 3 "$ARCHINSTALL_CREDS" 2>/dev/null || rm -f "$ARCHINSTALL_CREDS"
    rm -f /tmp/input_result /tmp/password_result /tmp/menu_result

    # Reboot
    sleep 10
    reboot
}

# Handle Ctrl+C gracefully
trap 'echo -e "\n${YELLOW}Installation interrupted by user${NC}"; exit 1' INT

# Run main function
main "$@"
