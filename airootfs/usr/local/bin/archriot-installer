#!/bin/bash

# ArchRiot Automated Installer
# A simple TUI installer that automates the ArchRiot installation process
# Following the exact guidelines from ArchRiot README.md

set -e

# Debug mode - set to 1 to enable debug output
DEBUG_MODE="${DEBUG_MODE:-0}"



# Tokyo Night theme colors for output
RED='\033[38;5;203m'      # Tokyo Night red
GREEN='\033[38;5;158m'    # Tokyo Night green
YELLOW='\033[38;5;221m'   # Tokyo Night yellow
BLUE='\033[38;5;116m'     # Tokyo Night cyan
PURPLE='\033[38;5;183m'   # Tokyo Night purple
ORANGE='\033[38;5;215m'   # Tokyo Night orange
GRAY='\033[38;5;59m'      # Tokyo Night comment gray
NC='\033[0m' # No Color

# Global variables
SELECTED_DISK=""
USERNAME=""
PASSWORD=""
ROOT_PASSWORD=""
LUKS_PASSWORD=""
HOSTNAME=""
WIFI_INTERFACE=""
SELECTED_TIMEZONE=""
SELECTED_KEYBOARD=""
ARCHINSTALL_CONFIG="/tmp/archriot-config.json"

# Logging functions with Tokyo Night styling
log() {
    echo -e "${GRAY}[$(date '+%H:%M:%S')]${NC} $1"
}

error() {
    echo -e "${RED}[âœ— ERROR]${NC} $1"
}

success() {
    echo -e "${GREEN}[âœ“ SUCCESS]${NC} $1"
}

warn() {
    echo -e "${ORANGE}[âš  WARNING]${NC} $1"
}

# Check if dialog is available, fallback to basic prompts
if ! command -v dialog &> /dev/null; then
    echo "Dialog not found. Using basic prompts."
    USE_DIALOG=false
else
    USE_DIALOG=true
fi

# Dialog wrapper functions
show_dialog() {
    if $USE_DIALOG; then
        # Handle different dialog types appropriately
        case "$1" in
            --infobox)
                # Infobox doesn't need input redirection
                # Always return 0 for infobox since it's non-interactive
                dialog "$@" >&2 || true
                return 0
                ;;
            *)
                # Other dialogs need full terminal access
                dialog "$@" 2>&1 >/dev/tty
                local exit_code=$?
                return $exit_code
                ;;
        esac
    else
        # Fallback for basic prompts
        case "$1" in
            --msgbox)
                echo "$3"
                read -p "Press Enter to continue..."
                ;;
            --yesno)
                while true; do
                    read -p "$3 (y/n): " yn
                    case $yn in
                        [Yy]* ) return 0;;
                        [Nn]* ) return 1;;
                        * ) echo "Please answer yes or no.";;
                    esac
                done
                ;;
            --infobox)
                echo "$3"
                ;;
        esac
    fi
}

input_dialog() {
    if $USE_DIALOG; then
        dialog --inputbox "$1" 12 60 2>/tmp/input_result >&2
        if [ $? -eq 0 ]; then
            cat /tmp/input_result
            rm -f /tmp/input_result
        else
            echo ""
        fi
    else
        read -p "$1: " input
        echo "$input"
    fi
}

password_dialog() {
    if $USE_DIALOG; then
        dialog --passwordbox "$1" 12 60 2>/tmp/password_result >&2
        if [ $? -eq 0 ]; then
            cat /tmp/password_result
            rm -f /tmp/password_result
        else
            echo ""
        fi
    else
        read -s -p "$1: " password
        echo
        echo "$password"
    fi
}

menu_dialog() {
    local title="$1"
    local text="$2"
    shift 2

    if $USE_DIALOG; then
        dialog --clear --menu "$title" 15 60 8 "$@" 2>/tmp/dialog_result >&2
        if [ $? -eq 0 ]; then
            cat /tmp/dialog_result
            rm -f /tmp/dialog_result
        else
            rm -f /tmp/dialog_result
            echo ""
        fi
    else
        echo "$text"
        echo
        local i=1
        while [ $# -gt 0 ]; do
            echo "$i) $2"
            shift 2
            i=$((i + 1))
        done
        echo
        read -p "Select option (1-$((i-1))): " choice
        if [[ "$choice" =~ ^[0-9]+$ ]] && [ "$choice" -ge 1 ] && [ "$choice" -lt "$i" ]; then
            echo "$choice"
        else
            echo ""
        fi
    fi
}

# Welcome screen
show_welcome() {
    clear
    show_dialog --msgbox "ðŸ´â€â˜ ï¸ ArchRiot Installer

Welcome to the ArchRiot automated installer!

This installer will:
â€¢ Set up WiFi (if needed)
â€¢ Select installation disk
â€¢ Configure user account
â€¢ Install Arch Linux with ArchRiot-optimized settings
â€¢ Install ArchRiot desktop environment

The installation follows the exact process from the ArchRiot README.md

IMPORTANT: Disk encryption (LUKS) is required and will be enabled automatically." 18 75

    if ! show_dialog --yesno "Do you want to continue with the ArchRiot installation?" 8 65; then
        exit 0
    fi
}

# Check internet connectivity
check_internet() {
    log "Checking internet connectivity..."

    if ping -c 1 google.com &>/dev/null || ping -c 1 8.8.8.8 &>/dev/null; then
        success "Internet connection available"
        return 0
    else
        error "No internet connection detected"
        return 1
    fi
}

# WiFi setup function
setup_wifi() {
    log "Checking network connectivity..."

    # Check if already connected
    if check_internet; then
        log "Already connected to internet, skipping WiFi setup"
        return 0
    fi

    # Check for wireless interfaces
    WIFI_INTERFACES=$(iw dev 2>/dev/null | grep Interface | awk '{print $2}' || echo "")

    if [ -z "$WIFI_INTERFACES" ]; then
        if show_dialog --yesno "No WiFi interfaces found.

Do you have an ethernet connection?
â€¢ Yes: Continue with ethernet
â€¢ No: Exit installer

Continue with ethernet connection?" 12 60; then
            warn "No WiFi available, using ethernet connection"
            if ! check_internet; then
                error "No internet connection available via ethernet. Please check your connection."
                exit 1
            fi
            return 0
        else
            log "Installation cancelled - no network interface available"
            exit 1
        fi
    fi

    # Use first WiFi interface
    WIFI_INTERFACE=$(echo "$WIFI_INTERFACES" | head -1)
    log "Found WiFi interface: $WIFI_INTERFACE"

    show_dialog --msgbox "WiFi Setup Required

No internet connection detected.
Setting up WiFi on interface: $WIFI_INTERFACE

The next screen will scan for networks..." 12 65

    # Scan for networks
    log "Scanning for WiFi networks..."
    iwctl station "$WIFI_INTERFACE" scan </dev/null >/dev/null 2>&1
    if [ $? -ne 0 ]; then
        error "WiFi scan failed on interface $WIFI_INTERFACE. Check hardware or try ethernet."
        if show_dialog --yesno "Retry scan?" 8 50; then
            setup_wifi
            return
        else
            warn "Skipping WiFi - checking ethernet"
            if ! check_internet; then
                error "No internet connection available. Cannot proceed with installation."
                exit 1
            fi
            return 0
        fi
    fi
    sleep 5

    # Get available networks - SIMPLE and RELIABLE


    # Debug: Show raw iwctl output
    RAW_OUTPUT=$(iwctl station "$WIFI_INTERFACE" get-networks </dev/null 2>&1)
    if [ "$DEBUG_MODE" = "1" ]; then
        log "Raw iwctl output: $RAW_OUTPUT"
    fi

    # Use simple iwctl command and parse cleanly - handle network names with spaces
    NETWORKS=$(echo "$RAW_OUTPUT" | awk '
        /--------/ { flag=1; next }
        flag && /^[[:space:]]*[>]*[[:space:]]*[A-Za-z0-9]/ {
            # Remove leading whitespace and > symbol
            gsub(/^[[:space:]]*[>]*[[:space:]]*/, "")
            # Extract network name (everything before "psk", "open", "8021x", etc.)
            if (match($0, /^[^[:space:]]+[[:space:]]+[A-Za-z0-9]*[[:space:]]+/)) {
                # Network name with spaces - extract up to security column
                gsub(/[[:space:]]+(psk|open|8021x|none)[[:space:]]+.*$/, "")
                print
            } else {
                # Simple network name without spaces
                print $1
            }
        }' | head -10)

    if [ -z "$NETWORKS" ]; then
        if [ "$DEBUG_MODE" = "1" ]; then
            log "DEBUG: No networks parsed. Raw output was: $RAW_OUTPUT"
        fi
        if show_dialog --yesno "No WiFi networks found.

This could happen if:
â€¢ WiFi is disabled
â€¢ No networks are in range
â€¢ WiFi adapter needs time to initialize

Do you want to:
â€¢ Yes: Retry scanning for networks
â€¢ No: Continue without WiFi (requires ethernet)

Retry WiFi scan?" 15 60; then
            log "Retrying WiFi scan..."
            setup_wifi
            return
        else
            warn "Skipping WiFi setup - checking ethernet connection"
            if ! check_internet; then
                error "No internet connection available. Cannot proceed with installation."
                exit 1
            fi
            return 0
        fi
    fi



    # Create menu items for dialog
    MENU_ITEMS=()
    i=1
    while IFS= read -r network; do
        if [ -n "$network" ] && [ "$network" != "Available" ] && [ "$network" != "networks" ]; then
            MENU_ITEMS+=("$i" "$network")
            i=$((i + 1))
        fi
    done <<< "$NETWORKS"

    # Count networks accurately after filtering for debug logging
    NETWORK_COUNT=$((${#MENU_ITEMS[@]} / 2))
    if [ "$DEBUG_MODE" = "1" ]; then
        log "Found $NETWORK_COUNT networks: $(echo "$NETWORKS" | tr '\n' ', ')"
    fi

    if [ ${#MENU_ITEMS[@]} -eq 0 ]; then
        if show_dialog --yesno "No valid WiFi networks found after scanning.

Do you want to:
â€¢ Yes: Retry WiFi setup
â€¢ No: Continue without WiFi (requires ethernet)

Retry WiFi setup?" 12 60; then
            log "Retrying WiFi setup..."
            setup_wifi
            return
        else
            warn "Continuing without WiFi - checking ethernet connection"
            if ! check_internet; then
                error "No internet connection available. Cannot proceed with installation."
                exit 1
            fi
            return 0
        fi
    fi

    # Show network selection menu
    if [ "$DEBUG_MODE" = "1" ]; then
        echo "DEBUG: MENU_ITEMS array has ${#MENU_ITEMS[@]} items:" >&2
        for ((i=0; i<${#MENU_ITEMS[@]}; i+=2)); do
            echo "DEBUG: MENU_ITEMS[$i]='${MENU_ITEMS[i]}' MENU_ITEMS[$((i+1))]='${MENU_ITEMS[i+1]}'" >&2
        done
    fi

    SELECTION=$(menu_dialog "WiFi Networks" "Select a WiFi network:" "${MENU_ITEMS[@]}")

    if [ "$DEBUG_MODE" = "1" ]; then
        echo "DEBUG: Raw selection result: '$SELECTION'" >&2
    fi

    if [ -z "$SELECTION" ]; then
        if show_dialog --yesno "No WiFi network selected.

Do you want to:
â€¢ Yes: Retry WiFi setup
â€¢ No: Continue without WiFi (requires ethernet connection)

Retry WiFi setup?" 12 60; then
            log "Retrying WiFi setup..."
            setup_wifi
            return
        else
            warn "Continuing without WiFi setup - ethernet connection required"
            if ! check_internet; then
                error "No internet connection available. Cannot proceed with installation."
                exit 1
            fi
            return 0
        fi
    fi

    # Validate selection is a number
    if ! [[ "$SELECTION" =~ ^[0-9]+$ ]]; then
        error "Invalid network selection: '$SELECTION'"
        exit 1
    fi

    # Debug: Show networks list for verification
    if [ "$DEBUG_MODE" = "1" ]; then
        echo "DEBUG: Full NETWORKS list:" >&2
        echo "$NETWORKS" | nl >&2
        echo "DEBUG: Total network lines: $(echo "$NETWORKS" | wc -l)" >&2
    fi

    # Get selected network name
    SELECTED_NETWORK=$(echo "$NETWORKS" | sed -n "${SELECTION}p" 2>/dev/null | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//')

    if [ "$DEBUG_MODE" = "1" ]; then
        echo "DEBUG: Selected network (line $SELECTION): '$SELECTED_NETWORK'" >&2
    fi

    if [ -z "$SELECTED_NETWORK" ]; then
        if [ "$DEBUG_MODE" = "1" ]; then
            echo "DEBUG: Failed to get network at line $SELECTION" >&2
            echo "DEBUG: Available lines in NETWORKS:" >&2
            echo "$NETWORKS" | cat -n >&2
        fi
        error "Invalid network selection: selection $SELECTION out of range"
        exit 1
    fi

    log "Selected network: $SELECTED_NETWORK"

    # Get password
    WIFI_PASSWORD=$(password_dialog "Enter password for '$SELECTED_NETWORK'")

    if [ -z "$WIFI_PASSWORD" ]; then
        # Try connecting without password (open network)
        log "Attempting to connect to open network..."
        iwctl station "$WIFI_INTERFACE" connect "$SELECTED_NETWORK" </dev/null >/dev/null 2>&1
    else
        # Connect with password
        log "Connecting to WiFi network..."
        iwctl station "$WIFI_INTERFACE" connect "$SELECTED_NETWORK" --passphrase "$WIFI_PASSWORD" </dev/null >/dev/null 2>&1
    fi

    # Wait a moment and check connection
    sleep 5

    if check_internet; then
        success "Successfully connected to WiFi"
    else
        if show_dialog --yesno "WiFi Connection Failed

Failed to connect to '$SELECTED_NETWORK'.

This could be due to:
â€¢ Incorrect password
â€¢ Network issues
â€¢ Signal strength problems

Do you want to:
â€¢ Yes: Retry WiFi setup
â€¢ No: Continue without WiFi (requires ethernet)

Retry WiFi setup?" 15 60; then
            log "Retrying WiFi setup..."
            setup_wifi
            return
        else
            warn "Continuing without WiFi - checking ethernet connection"
            if ! check_internet; then
                error "No internet connection available. Cannot proceed with installation."
                exit 1
            fi
            return 0
        fi
    fi
}

# Disk selection function
select_disk() {
    log "Scanning available disks..."

    # Get list of disks (excluding loop devices, ram, etc.)
    DISKS=$(lsblk -dno NAME,SIZE,MODEL | grep -E '^(sd|nvme|vd|hd)' | head -10)

    if [ -z "$DISKS" ]; then
        error "No suitable disks found"
        exit 1
    fi

    # Create menu items
    MENU_ITEMS=()
    while IFS= read -r disk_line; do
        if [ -n "$disk_line" ]; then
            DISK_NAME=$(echo "$disk_line" | awk '{print $1}')
            DISK_INFO="$disk_line"
            MENU_ITEMS+=("$DISK_NAME" "$DISK_INFO")
        fi
    done <<< "$DISKS"

    # Show disk selection menu
    SELECTED_DISK=$(menu_dialog "Disk Selection" "âš ï¸  WARNING: Selected disk will be COMPLETELY ERASED!

Select installation disk:" "${MENU_ITEMS[@]}")

    if [ -z "$SELECTED_DISK" ]; then
        show_dialog --msgbox "Installation Cancelled

No disk was selected for installation.

A disk must be selected to install ArchRiot.
The installer will now exit." 10 50
        log "Installation cancelled - no disk selected"
        exit 1
    fi

    # Confirm selection
    DISK_INFO=$(echo "$DISKS" | grep "^$SELECTED_DISK")

    if ! show_dialog --yesno "âš ï¸  FINAL WARNING âš ï¸

You selected: $DISK_INFO

This disk will be COMPLETELY ERASED and partitioned for ArchRiot installation.

Are you absolutely sure you want to continue?" 12 70; then
        log "Disk selection cancelled by user"
        exit 0
    fi

    SELECTED_DISK="/dev/$SELECTED_DISK"
    success "Selected disk: $SELECTED_DISK"
}

# User setup function
setup_user() {
    log "Setting up user account..."

    # Get hostname
    HOSTNAME=$(input_dialog "Enter hostname for this computer")
    while [ -z "$HOSTNAME" ] || [[ ! "$HOSTNAME" =~ ^[a-zA-Z0-9-]+$ ]]; do
        HOSTNAME=$(input_dialog "Invalid hostname. Enter hostname (letters, numbers, hyphens only)")
    done

    # Get username
    USERNAME=$(input_dialog "Enter username")
    while [ -z "$USERNAME" ] || [[ ! "$USERNAME" =~ ^[a-z_][a-z0-9_-]*$ ]]; do
        USERNAME=$(input_dialog "Invalid username. Enter username (lowercase, start with letter)")
    done

    # Get user password
    PASSWORD=$(password_dialog "Enter password for user '$USERNAME'")
    while [ -z "$PASSWORD" ] || [ ${#PASSWORD} -lt 6 ]; do
        PASSWORD=$(password_dialog "Password too short. Enter password (minimum 6 characters)")
    done

    # Confirm user password
    PASSWORD_CONFIRM=$(password_dialog "Confirm user password")
    while [ "$PASSWORD" != "$PASSWORD_CONFIRM" ]; do
        warn "Passwords do not match"
        PASSWORD=$(password_dialog "Enter password for user '$USERNAME'")
        PASSWORD_CONFIRM=$(password_dialog "Confirm user password")
    done

    # Get root password
    ROOT_PASSWORD=$(password_dialog "Enter root password")
    while [ -z "$ROOT_PASSWORD" ] || [ ${#ROOT_PASSWORD} -lt 6 ]; do
        ROOT_PASSWORD=$(password_dialog "Root password too short. Enter password (minimum 6 characters)")
    done

    # Confirm root password
    ROOT_PASSWORD_CONFIRM=$(password_dialog "Confirm root password")
    while [ "$ROOT_PASSWORD" != "$ROOT_PASSWORD_CONFIRM" ]; do
        warn "Root passwords do not match"
        ROOT_PASSWORD=$(password_dialog "Enter root password")
        ROOT_PASSWORD_CONFIRM=$(password_dialog "Confirm root password")
    done

    # Get LUKS encryption password
    LUKS_PASSWORD=$(password_dialog "Enter disk encryption (LUKS) password")
    while [ -z "$LUKS_PASSWORD" ] || [ ${#LUKS_PASSWORD} -lt 8 ]; do
        LUKS_PASSWORD=$(password_dialog "Encryption password too short. Enter password (minimum 8 characters)")
    done

    # Confirm LUKS password
    LUKS_PASSWORD_CONFIRM=$(password_dialog "Confirm disk encryption password")
    while [ "$LUKS_PASSWORD" != "$LUKS_PASSWORD_CONFIRM" ]; do
        warn "Encryption passwords do not match"
        LUKS_PASSWORD=$(password_dialog "Enter disk encryption (LUKS) password")
        LUKS_PASSWORD_CONFIRM=$(password_dialog "Confirm disk encryption password")
    done

    success "User configuration complete"
    log "Hostname: $HOSTNAME"
    log "Username: $USERNAME"
}

# Create archinstall configuration
create_archinstall_config() {
    log "Creating archinstall configuration..."

    cat > "$ARCHINSTALL_CONFIG" << EOF
{
    "disk_config": {
        "config_type": "default_layout",
        "device_modifications": [
            {
                "device": "$SELECTED_DISK",
                "partitions": [
                    {
                        "type": "primary",
                        "start": "1MiB",
                        "size": "512MiB",
                        "boot": true,
                        "esp": true,
                        "filesystem": {
                            "type": "fat32"
                        }
                    },
                    {
                        "type": "primary",
                        "start": "513MiB",
                        "size": "100%",
                        "encrypted": true,
                        "password": "$LUKS_PASSWORD",
                        "filesystem": {
                            "type": "btrfs"
                        }
                    }
                ]
            }
        ]
    },
    "users": [
        {
            "username": "$USERNAME",
            "!password": "$PASSWORD",
            "sudo": true
        }
    ],
    "!root-password": "$ROOT_PASSWORD",
    "audio_config": {
        "audio": "pipewire"
    },
    "kernels": ["linux"],
    "locale_config": {
        "sys_lang": "en_US.UTF-8",
        "sys_enc": "UTF-8",
        "keyboard": "$SELECTED_KEYBOARD"
    },
    "mirror_config": {
        "custom_mirrors": [],
        "mirror_regions": {
            "United States": ["https://geo.mirror.pkgbuild.com/"]
        }
    },
    "nic": {
        "type": "nm"
    },
    "ntp": true,
    "packages": [
        "wget", "curl", "git", "base-devel", "networkmanager", "dialog", "iw", "iwd",
        "sudo", "nano", "vim", "openssh", "rsync", "unzip", "zip", "htop",
        "pipewire", "pipewire-alsa", "pipewire-pulse", "pipewire-jack",
        "intel-ucode", "amd-ucode", "dosfstools", "e2fsprogs", "btrfs-progs",
        "firefox", "python", "python-pip", "neovim"
    ],
    "profile_config": null,
    "silent": false,
    "timezone": "$SELECTED_TIMEZONE"
}
EOF

    success "Configuration file created: $ARCHINSTALL_CONFIG"
}

# Run archinstall
run_archinstall() {
    log "Starting automated Arch Linux installation..."

    show_dialog --msgbox "Starting Installation

The automated installation will now begin.
This process may take 10-30 minutes depending on your internet speed.

The installer will:
â€¢ Partition and encrypt $SELECTED_DISK
â€¢ Install base Arch Linux system
â€¢ Configure bootloader and user account
â€¢ Set up networking and audio

Please be patient..." 14 70

    # Run archinstall with our configuration
    if archinstall --config "$ARCHINSTALL_CONFIG" --silent; then
        success "Arch Linux installation completed successfully"
    else
        error "Arch Linux installation failed"
        exit 1
    fi
}

# Install ArchRiot in the new system
install_archriot() {
    log "Installing ArchRiot desktop environment..."

    show_dialog --msgbox "Installing ArchRiot

Now installing the ArchRiot desktop environment in your new system.
This will download and install:
â€¢ Hyprland compositor
â€¢ ArchRiot configurations and themes
â€¢ Essential applications
â€¢ Development tools

This may take 15-30 minutes..." 15 70
    # Transfer WiFi credentials to new system (if any exist)
    transfer_wifi_credentials

    # chroot into the new system and run ArchRiot setup
    arch-chroot /mnt /bin/bash << 'CHROOT_EOF'
# Ensure network is available in chroot
systemctl enable NetworkManager
systemctl start NetworkManager

# Wait a moment for network
sleep 5

# Download and run ArchRiot setup
echo "Downloading ArchRiot setup script..."
if curl -fsSL https://ArchRiot.org/setup.sh | bash; then
    echo "ArchRiot installation completed successfully"
else
    echo "ArchRiot installation failed, but base system is installed"
    exit 1
fi
CHROOT_EOF

    if [ $? -eq 0 ]; then
        success "ArchRiot installation completed successfully"
    else
        warn "ArchRiot installation encountered issues, but base system is installed"
    fi
}

# Transfer WiFi credentials to new system
transfer_wifi_credentials() {
    log "Transferring WiFi credentials to new system..."

    # Check if NetworkManager connections exist
    if [ -d "/etc/NetworkManager/system-connections" ]; then
        # Create target directory
        mkdir -p /mnt/etc/NetworkManager/system-connections

        # Copy connection files
        if ls /etc/NetworkManager/system-connections/* >/dev/null 2>&1; then
            cp /etc/NetworkManager/system-connections/* /mnt/etc/NetworkManager/system-connections/ 2>/dev/null || true
            chmod 600 /mnt/etc/NetworkManager/system-connections/* 2>/dev/null || true
            success "WiFi credentials transferred to new system"
        else
            log "No WiFi connections to transfer"
        fi
    else
        log "No NetworkManager connections found"
    fi
}

# Select timezone
select_timezone() {
    log "Setting up timezone..."

    # Get current timezone as default
    local current_tz=$(timedatectl show --property=Timezone --value 2>/dev/null || echo "UTC")

    local timezones=(
        "UTC" "UTC (Universal)"
        "America/New_York" "US Eastern"
        "America/Chicago" "US Central"
        "America/Los_Angeles" "US Pacific"
        "Europe/London" "UK"
        "Europe/Paris" "Europe Central"
        "Asia/Tokyo" "Japan"
        "Australia/Sydney" "Australia"
    )

    SELECTED_TIMEZONE=$(menu_dialog "Timezone Selection" "Current: $current_tz\nSelect timezone:" "${timezones[@]}")

    # Use current timezone if nothing selected
    if [[ -z "$SELECTED_TIMEZONE" ]]; then
        SELECTED_TIMEZONE="$current_tz"
    fi

    # Set timezone
    timedatectl set-timezone "$SELECTED_TIMEZONE" 2>/dev/null || {
        SELECTED_TIMEZONE="UTC"
        timedatectl set-timezone "UTC"
    }

    success "Timezone set to: $SELECTED_TIMEZONE"
}

# Select keyboard layout
select_keyboard() {
    log "Setting up keyboard layout..."

    # Common keyboard layouts
    local keyboards=(
        "us" "US English"
        "uk" "UK English"
        "de" "German"
        "fr" "French"
        "es" "Spanish"
        "it" "Italian"
        "pt" "Portuguese"
        "ru" "Russian"
        "jp" "Japanese"
        "kr" "Korean"
        "cn" "Chinese"
        "dvorak" "Dvorak"
        "colemak" "Colemak"
    )

    SELECTED_KEYBOARD=$(menu_dialog "Keyboard Layout" "Select your keyboard layout:" "${keyboards[@]}")

    # Use US layout as fallback if nothing selected (ESC pressed)
    if [[ -z "$SELECTED_KEYBOARD" ]]; then
        SELECTED_KEYBOARD="us"
        warn "No keyboard layout selected, using US English as default"
    fi

    # Apply keyboard layout immediately
    loadkeys "$SELECTED_KEYBOARD" 2>/dev/null || true

    success "Keyboard layout selected: $SELECTED_KEYBOARD"
}

# Main installation flow
main() {
    # Clear screen and show welcome
    clear
    show_welcome

    # Setup network if needed
    setup_wifi

    # Select timezone
    select_timezone

    # Select keyboard layout
    select_keyboard

    # Select installation disk
    select_disk

    # Get user information
    setup_user

    # Create archinstall configuration
    create_archinstall_config

    # Final confirmation
    if ! show_dialog --yesno "Ready to Install

Configuration Summary:
â€¢ Disk: $SELECTED_DISK (will be encrypted with LUKS)
â€¢ Hostname: $HOSTNAME
â€¢ Username: $USERNAME (with sudo access)
â€¢ Root account: enabled with password
â€¢ Encryption: LUKS with your chosen password
â€¢ Timezone: $SELECTED_TIMEZONE
â€¢ Keyboard: $SELECTED_KEYBOARD
â€¢ Filesystem: BTRFS with compression
â€¢ Bootloader: systemd-boot
â€¢ Audio: PipeWire
â€¢ Desktop: ArchRiot (Hyprland)

Proceed with installation?" 18 60; then
        log "Installation cancelled by user"
        exit 0
    fi

    # Run the installation
    run_archinstall

    # Install ArchRiot
    install_archriot

    # Installation complete
    show_dialog --msgbox "ðŸŽ‰ Installation Complete!

ArchRiot has been successfully installed on your system.

The system will now reboot. After reboot:
â€¢ Enter your disk encryption password
â€¢ Log in with your user account
â€¢ Enjoy your new ArchRiot system!

Note: The first boot may take a few extra moments to initialize services." 14 70

    success "ArchRiot installation completed successfully!"
    log "System will reboot in 10 seconds..."

    # Clean up
    rm -f "$ARCHINSTALL_CONFIG" /tmp/input_result /tmp/password_result /tmp/menu_result

    # Reboot
    sleep 10
    reboot
}

# Handle Ctrl+C gracefully
trap 'echo -e "\n${YELLOW}Installation interrupted by user${NC}"; exit 1' INT

# Run main function
main "$@"
